# ChIP-seq analysis {#chipseq}


```{r setup_chip_seq, include=FALSE}
knitr::opts_chunk$set(echo      = TRUE,
                      message   = FALSE, 
                      error     = FALSE,
                      cache     = TRUE,
                      out.width = "60%",
                      fig.width = 5,
                      fig.align = 'center')
```

Protein-DNA interactions are responsible for a large part of the gene expression regulation. Proteins such as transcription factors as well as histones are directly related to how much and in which contexts the genes are expressed. Some of these concepts are already introduced in Chapter \@ref(intro) if readers need a more in depth introduction. In this chapter, we will introduce how to process and analyze ChIP-seq data in order to identify genome-wide protein binding sites and to discover underlying sequence context via transcription factor binding-site motifs.

## Regulatory Protein-DNA Interactions
One of the most fascinating biological phenomena is the fact that a myriad of  different cell types, in a multicellular organisms, are encoded by one single genome. How exactly this is achieved is still a
major unanswered question in biology. 
Cell types differ based on a multitude of features:
their size, shape, mobility, surface receptors, metabolic content.
However, the main predominant feature which influences all of the above is which
genes are expressed in each cell type. 
Therefore, if we can understand what controls which
genes will be expressed, and where they will be expressed, 
we can start forming a picture of how a single genomic template, 
can give rise to a complex organism.

As explained in chapter \@ref(intro), gene expression is controlled by a special class of genes called 
transcription factors - genes which control other genes. 
Transcription factor genes encode  proteins which
can bind to the DNA, and control whether a certain part of DNA will be
transcribed (expressed), or stay silent (repressed). 
They program the expression patterns in each cell.
Transcription factors contain DNA binding domains - specifically folded protein sequences
which recognize specific DNA motifs (a short nucleotides sequence).
Such sequence binding imparts transcription factors with specificity - 
transcription factors do not bind everywhere on the DNA, rather they are localized to 
short stretches which contain the corresponding DNA motif.

DNA in the nucleus is wrapped around a protein complex called the histone complex.
Histones form a chain of beads along the DNA. By changing their position, histones can make
certain parts of the DNA more or less accessible to transcription 
factors. Histone complexes can be chemically modified with different post-translational modifications (see chapter \@ref(intro)). Such modifications change histone
mobility, and their interactions with different proteins, thereby creating
an additional regulatory layer on top of the DNA sequence.

In order to understand what are the target genes of a certain transcription factor,
and how it controls the gene expression we need to where on the DNA is the 
transcription factor located. 


## Measuring Protein-DNA interactions with ChIP-seq 

ChIP-seq, stands for chromatin immunoprecipitation followed by sequencing, is an experimental method for finding locations on DNA which are bound by proteins. It has been extensively used to study 
in-vivo binding preferences of transcription factors, and genomic distribution of modified histones.

In the remainder of this chapter, you will learn how to assess quality control
of ChIP-seq data sets, perform peak calling, to find bound regions, and 
assess the quality of the peak calling.

Once you have obtained peaks, you will learn how to perform sequence analysis
to construct motif models, and compare signals between experiments.
Biological experiment often contain multitude of consecutive steps. Each 
step can profoundly influence the quality of the data, and the subsequent analysis.
The computational biologist has to have an in depth knowledge of the experimental
design, and the underlying experimental steps, in order to choose the proper tools, 
and the type of the analysis, which will give proper and correct results [@kharchenko_2008; @kidder_2011; @landt_2012; @chen_2012; @felsani_2015].
In this chapter we will go through the main experimental steps in the
ChIP-seq analysis and address the most common experimental pitfalls.

The main principle of the method is use a specific antibody to enrich
DNA fragments which are bound by the protein of interest.

The DNA fragments are then sequenced, mapped onto the corresponding 
reference genome, and computationally analyzed to discriminate regions which
were really bound by the protein, from the background regions.

The experimental methodology consists of the following steps:

1. Cross linking of cells with formaldehyde, to bind the proteins to the DNA.
This process covalently links the proteins to the DNA.

2. Fragmentation of DNA using sonication or enzymatic digestion - shearing
of DNA into small fragments (ranging from 50 - 500 bp)

3. Immunoprecipitation using a specific antibody. An immunoprecipitation step
which enriches fragments bound by the protein.

4. Cross-link reversal. Frees the DNA fragments for further processing.

5. Size selection of DNA fragments. Only fragments of certain length are used in the
library preparation and sequencing.

6. Fragment amplification using PCR. The amount of DNA is a limiting step for the
protocol. Therefore the fragments need to be amplified using PCR.

7. DNA fragment sequencing 

```{r ChIP-seq-Protocol-plot, echo=FALSE, include=TRUE, fig.cap="Main experimental steps in the ChIP-seq protocol"}
knitr::include_graphics('./Figures/Chip-Seq_Protocol_Extended.png')
```


After sequencing, the role of the computational biologist is to assess the 
quality of the experiment, find the location of the protein of interest, and
finally, to integrate with existing data sets.

Each step of the experimental protocol can affect on the quality
of the data set, and the subsequent analysis steps. It is, therefore, of crucial
importance to perform quality control for every sequenced experiment.

## Factors that affect ChIP-seq experiment and analysis quality

### Antibody specificity

Antibody specificity is a term which refers to how strongly an antibody
binds to it's preferred target, with respect to everything else present in the cell.
It is the paramount measure influencing the successful execution of a ChIP
experiment.
Antibodies can bind multiple proteins with the same affinity. 
This is called antibody cross-reactivity. If an antibody cross-reacts with
multiple proteins, the results of a ChIP experiment will be ambiguous.
Instead of finding where our protein binds to the DNA, we will get a
superposition of binding of multiple proteins.
Such data are impossible to analyze correctly, and will produce false conclusions.
There are many experimental procedures for validating antibody specificities, and 
an antibody should pass multiple tests in order to be considered valid.
The exact recommendations are listed by the ENCODE consortium [@landt_2012].

Every time we are analyzing a new ChIP-seq experiment, we have to take our time
to convince ourselves that all of the appropriate experimental controls were performed
to validate the antibody specificity[@Wardle_2015].


### Sequencing depth

Variation in sequencing depth is the first systematic technical bias we 
encounter in ChIP-seq experiments. Namely, different samples will contain different number of 
sequenced reads. Different sequencing depth influences our ability to detect 
enriched regions, and complicates comparisons between samples [@jung_2014].
Statistical procedure of removing the influence of sequencing depth on the
quantification is called depth scaling - we calculate a scaling factor which
is used to multiply the signal strength before the comparison. 
There are multiple methods for normalization, and each method comes with it's assumptions.
**Scale normalization** is done by dividing the read counts (in certain genomic locations)
by the total amount of sequenced reads. This method presumes that the ChIP
efficiency worked equally well in all studied conditions. Because the ChIP efficiency
differs in different antibodies, it is often unsuitable for comparisons of ChIP-seq
experiments done on different proteins.
**Robust normalization** tries to locate genomic regions which do not change between 
different  biological conditions (regions where the protein is constantly bound), 
and then uses the sum of the reads in those regions as the scaling factor. This
method presumes that we can reliably identify regions which do not change [@shao_2012].
**Background normalization** presumes that the genome can be split into two categories:
background regions, and true signal regions. It then uses the number of reads in the
background regions to define the scaling factor [@liang_2012].
**External normalization** uses external reference for normalization - we
add known amounts of chromatin from a distant species, or artificial spike-ins which are then
used as a scaling reference. This is used when we thing there are global changes
in the biding profiles between two biological conditions - very large changes in the 
signal profile [@bonhoure_2014].

The choice of normalization method depends on the type of the analysis [@angelini_2015];
if we want to quantitatively compare the abundance of different histone marks in 
different cell types, we will need different normalization procedure than if
we want to compare TF binding in the same setting.


### PCR duplication

The amounts of the DNA obtained after the ChIP experiment are quite often lower
than the minimal amount which can be sequenced.
Polymerase chain reaction (PCR) is a procedure used for amplification of DNA fragments.
It is used to increase the amount of DNA in our sample prior to sequencing.
PCR is a stochastic procedure, meaning that the results of each PCR
reaction can not be predicted. Due to it's stochastic nature, PCR can
be a significant source of variability in the ChIP-seq experiments 
[@aird_2011; @benjamini_2012; @teng_2016]. As a quality control is necessary to 
check whether all of our samples have the same sequence properties - i.e. the
same enrichment of dinucleotides, such as CpG.
If the samples differ in their sequence properties, that means we have
to account for them during the analysis [@Teng_2017].


### Biological replicates

Biological replicates are independently executed ChIP-seq experiments from different
samples, corresponding to the same biological conditions. They are indispensable
for estimating ChIP quality, and give us an estimate of the variability in the
experiment which we can expect due to unknown biological variables.
Without biological replicates, it is statistically impossible to compare
ChIP-seq samples from different biological conditions, because we do not know
whether the observed changes are a result of the inherent biological variability
(the source of which we do not understand), or they result from the change
in the biological condition (different tissue or transcription factor used
in the experiment).
If we encounter and experimental setup which does not include biological 
replicates, we should be extremely skeptical about all conclusions derived
from such analysis.

### Control experiments

There are three types of control experiments which can be performed to control
for known and unknown experimental biases:

1. **Input control** - sequencing of genomic DNA without the immunoprecipitation step

2. **IgG control** - using a polyclonal mixture of non-specific IgG antibodies instead of a specific antibody

3. **Knockout control** - performing the ChIP experiment in a biological system which
does not contains our protein of interest (i.e. in a cell line where the transcription
factor was knocked out) [@krebs_2014].

Each type of control experiment controls for a certain set of experimental biases.

**Input control** is the most frequent type of control performed. 
It shows the differential susceptibility of genomic regions to the ChIP-procedure. 
Due to the hierarchical structure of  chromatin, different genomic regions have different propensities for cross-linking, 
sonication, and immunoprecipitation. This causes an uneven probability of
observing DNA fragments originating from different genomic regions.
Because different cell types (cell lines, and cancer cell lines), 
have different chromatin structure, ChIP samples will show a cell type specific
bias in observed enrichment profiles.
An important note to consider is that the input control is basically a 
reduced whole genome sequencing experiment, while the ChIP enriches for only a subset
of genomic regions. If both ChIP and Input samples are sequenced to the same
depth (same number of reads), the background distribution in the input sample will
be under sampled. It is recommended to sequence the Input sample to at least
double the amount of reads of the ChIP sample (ref)

**IgG control** uses a soup of nonspecific antibodies for to control for background
binding. In principle, the antibodies should be isolated from the same batch of
serum which was used to create the specific antibody (used for ChIP). It should, 
in theory, give a background profile of non-specific binding. 
The proper control, is however, seldom available. Additionally, because the antibodies
are unspecific, the amount of precipitated DNA will be low, and the samples
will require additional rounds of PCR amplification.

**KO control** is a ChIP experiment performed in the biological system where
the native protein is not present. Such experiment profiles the non-specific
binding of the antibody to other proteins, and directly to the DNA.
The primary, and only, concern is that the perturbation caused by the knock-out (knock-down),
changes the cell so much, that the ChIP profile is not comparable to the original cell.
This is the most accurate type of control experiment, however, it is frequently technically challenging
to perform - the cells are not viable after the knock out, or
it is knock out is impossible to perform.


### Using tagged proteins

If an antibody of sufficient quality is not available, it is possible
to resort to constructs where the protein of interest gets engineered
with a ChIP-able tag. The proper control for such experiments is to perform
the ChIP in the cell line containing the engineered protein, and without the
protein.
It must be noted that the tagging procedure can change the binding preferences
of the protein, and therefore the experimental conclusions.


## Pre-processing ChIP data

The focus of ChIP preprocessing is to check the quality of the sequencing
experiment, remove sequencing artifact, and find the genomic location of 
sequenced fragments using read mapping.

### Read quality control

The most frequently used tool for read quality control is FastQC (https://www.bioinformatics.babraham.ac.uk/projects/fastqc/). 
Regarding ChIP-seq analysis it provides three useful sets of information:

1. Per position read quality distribution

2. GC content content distribution, and comparison with genomic GC content distribution

3. Adapter contamination - information on the percentage of reads which contain
adapter sequences.

Due to the chemistry Illumina sequencing procedure, most of the artifacts are 
present in the 3' ends of reads.

### Adapter and Quality trimming

If the read quality distribution is not uniformly high, or the reads are contaminated
with sequencing adapters, the reads need to be trimmed.
This can be efficiently done using command following line tools: trimmomatic [@bolger_2014],
and flexbar[@dodt_2012].

After the reads have been cleaned, they are ready for mapping.

### Mapping

Mapping is a procedure of trying to locate the exact genomic location which
created each genomic fragment - each sequenced read. 
Several tools are available for mapping ChIP-seq data sets:
Bowtie, Bowtie2, BWA [@langmead_2009; @langmead_2012; @li_2009], and all of them have comparable sensitivity and 
specificity [@ruffalo_2011].
Read length is the variable with the biggest effect on the mapping procedure.
The longer the sequenced reads, the more uniquely can the read assigned
to a position on the genome. Reads which are assigned ambiguously to multiple
locations in the genome are called multi-mapping reads. Such fragments
are most often produced by repetitive genomic regions, such as retrotransposons, 
pseudogenes or paraloguous genes [@li_2014].
It is important to apriori decide whether such duplicated regions are of 
interest for the current experimental setup (i.e. whether we want to study transcription factor binding 
in olfactory receptors). If they are, then the multi-mapping
reads should be included in the analysis. If they are not, they should be omitted.
This is done during the mapping step, by limiting the number of locations to which a read can map.
The methodology of working with multi-mapping reads differs according to the
use case, and will not be considered in this chapter. For more information please
see the references [@chung_2011].

Current Illumina sequencing procedures enable sequencing of DNA
fragments from just one, or both ends.
Sequencing from both ends is called **paired-end** sequencing and greatly enhances
the sample **mappabillity** - percentage of genome which can be uniquely mapped. 
Additionally, it provides out of the box estimate of the
average DNA fragment length - a parameter which is important for quality control
and peak calling.
Although it would be always preferable to do paired-end sequencing it 
substantially increases the sequencing costs, which can be prohibitive.

Different reads, which map to the same genomic location (same chromosome, position, and strand),
are called **duplicated reads**. Such reads are an indication that the same 
DNA fragment was present multiple times during the library preparation. This
can happen due to high enrichment with highly specific antibodies, or such 
fragments can be artificially produced during PCR amplification. Because we do not know
the exact origin of the duplicated fragments, they are most often collapsed during
the peak calling procedure - i.e. when multiple reads map to the same chromosome,
position, and strand, only one read is used. If the transcription factor
binds to a small number of regions in the genome, such data reduction might be
too stringent, and we can increase the sensitivity by allowing up to __N__ different
reads, per position (i.e. if more than __N__ reads map to the same location, only
__N__ reads are kept for the downstream analysis).

Some peak calling algorithms have automated statistical methods for determining the number
of reads, per position, which will be used in the analysis [@zhang_2008].

An important consideration to take into account is the genome which was used in
the experiment. Cell lines, cancer samples, and personal genomes usually contain
structural genomic alteration which are not present in the reference genome 
(duplications, insertions, and deletions). Such regions can cause false 
negatives, and false positives in the ChIP-seq experiment.
If a region was present multiple times in the experimental system, and only a single
time in the reference genome, it will be relatively enriched in the final 
sequencing library. Such fragments will pile up on a single location during
the mapping step, and create an artificial peak, which can be falsely characterized
as a binding event.
Such regions are called **blacklisted** regions and should be removed from the
downstream analysis. The UCSC browser database (ref) contains tables with
such regions for the most commonly used model organism species.

## Computational Analysis of ChIP-seq data

The following tutorial presumes that the user is already familiar with 
the following technical and conceptual knowledge:

#### Technical requirements

The practical section presumes that the user knows how to use the following **R** tools:

- ggplot2 package 

- R objects, and classes, and object conversion (list, data.frame, matrix, vector)

- construction, and usage of functions

- GenomicRanges, GenomicFeatures, and GenomicAlignment Bioconductor packages

- Rle, coverage

#### Knowledge requirements for the tutorial

By this chapter you should be familiar with the following terms:

- Read filtering

- Read mapping

- File format

- Structure of **bed**, **gtf**, **wig**, **bigWig**, **bam**

- Uniquely-mapping and multi-mapping reads

- PCR duplicates

- biological and technical replicates

- + and - strand

- PCR - polymerase chain reaction

### Prerequisites

Please install the following **R** packages

```{r install, eval=FALSE, echo=TRUE, include=TRUE}
packages = c(
    'AnnotationHub',
    'Biostrings',
    'BSgenome',
    'BSgenome.Hsapiens.UCSC.hg38',
    'circlize',
    'ComplexHeatmap',
    'dplyr',
    'GenomicAlignments',
    'GenomicFeatures',
    'GenomicRanges',
    'GenomeInfoDB',
    'ggplot2',
    'Gviz',
    'JASPAR2018',
    'MotifDb',
    'motifRG',
    'motifStack',
    'normr',
    'rtracklayer',
    'seqLogo',
    'TFBSTools',
    'tidyr')
BiocManager::install(packages)
```



### The Data

Experimental data was downloaded from the public ENCODE (ref) database of 
ChIP-seq experiments.
The experiments were performed on a Lymphoblastoid cell line GM12878, and mapped
to the GRCh38 (hg38) version of the Human genome, using the standard ENCODE
ChIP-seq pipeline.

In this tutorial, for performance considerations, we have taken a subset of the
data which corresponds to the human chromosome 21 (chr21).

The data sets are located in the **compGenomRData** package.
The location of the data sets can be accessed using the **system.file** command,
in the following way:

```{r data_path}
data_path = system.file('extdata/chip-seq',package='compGenomRData')
```

The available data sets can be listed using the **list.files** command:

```{r Load_data, echo=TRUE, eval=TRUE, include=TRUE}
chip_files = list.files(data_path, full.names=TRUE)
```

```{r data_path.show, echo=FALSE, eval=TRUE, include=TRUE}
head(chip_files)
```

The data set consist of the following ChIP experiments:

1. Transcription factors: CTCF, SMC3, ZNF143, PolII (RNA polymerase 2)

2. Histone modifications: H3k4me3, H3k36me3, H3k27ac, H3k27me3

3. Various input samples

The first step in the ChIP-seq data analysis is to perform ChIP quality control

## ChIP Quality Control


While the goal of the read quality assessment is to check whether the sequencing
produced high enough number of high quality reads;
the goal of the ChIP quality control to ascertaining whether the chromatin immunoprecipitation
enrichment was successful.
This is a crucial step in the ChIP-seq analysis because it can help us
identify low quality ChIP samples, and give information about which experimental
steps went wrong.

There are four steps in the ChIP quality control:

1. Sample correlation clustering - clustering of the pair-wise correlations between
genome-wide signal profiles.

2. Data visualization in a genomic browser.

3. Average fragment length determination - determining whether the ChIP enriched
for fragments of a certain length.

4. Visualization of GC bias. Here we will plot the ChIP enrichment Vs the 
average GC content in the corresponding genomic bin.

### Sample Clustering

Clustering is an ordering procedure which groups samples by similarity -
the more similar samples are grouped closer to one another.
Clustering of ChIP signal profiles is used for two purposes:
The first one is to ascertain whether there is concordance between
biological replicates - biological replicates should show greater similarity
than ChIP of different proteins.
The second function is to see whether our experiments conform to known prior knowledge.
For example, we would expect to see proteins greater similarity between proteins
which belong to the same quaternary complex.

To quantify the ChIP signal we will firstly construct 1 kilobase wide tilling
windows over the genome, and subsequently count the number of reads
in each window, for each experiment. We will then normalize the counts, to
account for different total number of reads in each experiment, and finally 
calculate the correlation between all pairs of samples.
Although this procedure represents a crude way of data quantification, it provides sufficient
information to ascertain the data quality.

Using the **GenomeInfoDb** we will first fetch the chromosome lengths corresponding
to the hg38 version of the human genome, and filter the length for human
chromosome 21.


```{r sample_clustering.seqlen, message=FALSE, warning=FALSE}
# load the chromosome info package
library(GenomeInfoDb)

# fetch the chromosome lengths for the human genome
hg_chrs = fetchExtendedChromInfoFromUCSC('hg38')

# find the length of chromosome 21
hg_chrs = subset(hg_chrs, grepl('chr21$',UCSC_seqlevel))
    
```

**tileGenome** function from the **GenomicRanges** package constructs equally sized
windows over the genome of interest.
The function takes two arguments:

1. A vector of chromosome lengths

2. Window size

Firstly, we convert the chromosome lengths _data.frame_ into a _named vector_


```{r sample_clustering.seqlen_vector}
# downloaded hg_chrs is a data.frame object, we need to convert the data.frame
# into a named vector
seqlengths = with(hg_chrs, setNames(UCSC_seqlength, UCSC_seqlevel))
```

Then we construct the windows.

```{r sample_clustering.tilling_window}
# load the genomic ranges package
library(GenomicRanges)

# tileGenome function returns a list of GRanges of a given width, spanning
# the whole chromosome
tilling_window = tileGenome(seqlengths, tilewidth=1000)

# unlist converts the list to one GRanges object
tilling_window = unlist(tilling_window)
```

```{r sample_clustering.show_tilling_window, include=TRUE, echo=FALSE, eval=TRUE}
tilling_window
```

We will use the **summarizeOverlaps** function from the **GenomicAlignments** package
to count the number of reads in each genomic window.
The function will do the counting automatically for all our experiments.
**summarizeOverlaps** function returns a **SummarizedExperiment** object.
The object contains the counts, genomic ranges which were used for the quantification,
and the sample descriptions.

```{r sample_clustering.GenomicAlignments}
# load GenomicAlignments
library(GenomicAlignments)

# fetch bam files from the data folder
bam_files = list.files(data_path, full.names=TRUE, pattern='bam$')

# use summarizeOverlaps to count the reads
so = summarizeOverlaps(tilling_window, bam_files)

# extract the counts from the SummarizedExperiment
counts = assays(so)[[1]]
```


Different ChIP experiments were sequenced to different depth - each experiment
contains different number of reads. To remove the effect of the experimental
depth on the quantification, the samples need to be normalized.
Standard normalization procedure, for ChIP data, is to divide the 
counts in each tilling window by the total number of sequenced reads, and
multiply it with a constant factor (to avoid extremely small numbers).
This normalization procedure is called the **cpm** - counts per million.

\[
CPM = counts * (10^{6} / total\>number\>of\>reads)
\]



```{r sample_clustering.norm}
# calculate the cpm from the counts matrix
# the following command works because R calculates everything by columns
cpm = t(t(counts)*(1000000/colSums(counts)))
```

We remove all tiles which do not have overlapping reads.
Tiles with 0 counts do not provide any additional discriminatory power, rather, 
they introduce artificial similarity between the samples (i.e. samples with
a only a handful of bound regions will have a lot of tiles with 0 counts, while
they do not have to have any overlapping enriched tiles).

```{r sample_clustering.filter_cpm}
# remove all tiles which do not contain reads
cpm = cpm[rowSums(cpm) > 0,]
```

We use the sub function to shorten the column names of the cpm matrix.

```{r sample_clustering.change_colnames}
# change the formatting of the column names
# remove the .chr21.bam suffix
colnames(cpm) = sub('.chr21.bam','',   colnames(cpm))

# remove the GM12878_hg38 prefix
colnames(cpm) = sub('GM12878_hg38_','',colnames(cpm))
```

```{r sample_clustering.colnames, include=FALSE, eval=TRUE, echo=TRUE}
colnames(cpm)
```


Finally we calculate the pairwise pearson correlation coefficient using the
**cor** function.
The function takes as input an region X sample count matrix, and returns
a sample X sample matrix, where each field contains the correlation coefficient
between two samples.

```{r sample_clustering.correlation}
# calculates the pearson correlation coefficient between the samples
correlation_matrix = cor(cpm, method='pearson')
```

The *Heatmap* function from the **ComplexHeatmap** [@Gu_2016] package is used to visualize 
the correlation coefficient.
The function automatically performs hierarchical clustering - it groups the 
samples which have the highest pairwise correlation.
The diagonal represents the correlation of each sample with itself.


```{r sample-clustering-complex-heatmap, fig.cap='Heatmap showing ChIP-seq sample similarity using Pearson correlation coefficient'}
# load ComplexHeatmap
library(ComplexHeatmap)

# load the circlize package, and define the color palette which will be
# used in the heatmap
library(circlize)
heatmap_col = circlize::colorRamp2(c(-1,0,1),c('blue','white','red'))

# plot the heatmap using the Heatmap function
Heatmap(correlation_matrix, 
        col = heatmap_col)
```

Here we can see a perfect example of why quality control is important. 
**CTCF** is a zinc finger protein which co-localizes with the Cohesin complex.
**SMC3** is a sub unit of the Cohesin complex, and we would therefore expect to
see that the **SMC3** signal profile has high correlation with the **CTCF** signal profile.
This is true for the second biological replicate of **SMC3**, while the first
replicate (SMC3_r1) clusters with the input samples. This indicates that the
sample likely has low enrichment.
We can see that the ChIP and Input samples form separate cluster. This implies
that the ChIP samples have an enrichment of fragments.
Additionally, we see that the biological replicates of other experiments
cluster together.


### Visualization the Genome Browser


One of the first steps in any ChIP-seq analysis should be looking at the
data. By looking at the data we get an intuition about the quality of the
experiment, and start seeing preliminary correlations between the samples, which
we can use to guide our analysis.
This can be achieved either by plotting signal profiles around
regions of interest, or by loading data into a genome browser 
(such as IGV, or UCSC genome browsers).

Genome browsers are standalone applications which represent the genome
as a one dimensional (1D) coordinate systems. The browsers enable
simultaneous visualization and comparison of multiple types of annotations and experimental data.


Genome browsers can visualize most of the commonly used bioinformatics data formats:
bam, bed, wig, bigWig ...
The easiest way to access our data would be to load the .bam files into the browser.
This will show us the sequence, and position of every mapped read. If we want to
view multiple samples in parallel, loading every mapped read can be restrictive -
it takes up a lot of computational resources, and the amount of information 
makes the visual comparison hard to do.
We would like to convert our data so that we get a compressed visualization, 
which would show us the main properties of our samples, namely, the quality, and
the location of the enrichment.
This is achieved by summarizing the read enrichment into a signal profile - 
the whole experiment is converted into a numeric vector - a coverage vector. 
The vector contains the information of how many reads overlap each position 
in the genome.

We will proceed as follows: 
Firstly we will import a **.bam** file into **R**. Then we will calculate
the signal profile (construct the coverage vector), and finally, we export the
vector as a **.bigWig** file.

First we select one of the ChIP samples.

```{r genome_browser.file}
# list the bam files in the directory
# The '$' sign tells the pattern recognizer to omit bam.bai files
bam_files = list.files(data_path, full.names=TRUE, pattern='bam$')

# select the first bam file
chip_file = bam_files[1]
```

We will use the **readGAlignemnts** function from the **GenomicAlignemnts** 
package to load the reads into **R**, and then the **granges** function
to convert them into a **GRanges** object.

```{r genome_browser.alignments}
# load the genomic alignments package
library(GenomicAlignments)

# read the ChIP reads into R
reads = readGAlignments(chip_file)

# the reads need to be converted to a granges object
reads = granges(reads)
```

Because DNA fragments are being sequenced from their ends (both the 3' and 5' end), 
the read enrichment does not correspond to the exact location of the bound protein. 
Rather, reads end to form clusters of enrichment upstream and downstream of the true binding location.
To correct for this we use a small hack - before we create the signal profiles, 
we will extend the reads towards their __3'__ end. The reads are extended to
form fragments of 200 base pairs. This is an empiric measure, which 
corresponds to the average fragment size of the Illumina sample preparation kit.
The exact average fragment size will differ from 200 base pairs, but if the
deviation is not large (i.e. more than 200 base pairs), 
it will not affect the visual properties of our samples.

Read extension is done using the **resize** function. The function
takes two arguments:

1. width - resulting fragment width

2. fix - which position of the fragment should not be changed (if fix is set to start, 
the reads will be extended towards the __3'__ end, if fix is set to end, they will
be extended towards the __5'__ end)


```{r genome_browser.resize}
# extends the reads towards the 3' end
reads = resize(reads, width=200, fix='start')

# keeps only chromosome 21
reads = keepSeqlevels(reads, 'chr21', pruning.mode='coarse')
```

Conversion of reads into coverage vectors is done with the **coverage**
function.
The function takes only one argument (**width**), which corresponds to chromosome sizes.
For this purpose we can use the, previously created, **seqlengths** variable.
The **coverage** function converts the reads into a compressed **Rle** object

```{r genome_browser.coverage}
# convert the reads into a signal profile
cov = coverage(reads, width = seqlengths)
```

```{r genome_browser.coverage.show, include=TRUE, echo=FALSE, eval=TRUE}
head(cov)
```

The name of the output file is created by changing the file suffix from *.bam* to *.bigWig*

```{r genome_browser.rename}
# change the file extension from .bam to .bigWig
output_file = sub('.bam','.bigWig', chip_file)
```
 
Now we can use the **export.bw** function from the rtracklayer package to
write the bigWig file.

```{r genome_browser.export}
# load the rtracklayer package
library(rtracklayer)

# export the bigWig output file
export.bw(cov, 'output_file')
```


#### Gviz

We can create Genome browser like visualizations using the **Gviz** package.
Gviz is a too which enables exhaustive customized visualization of 
genomics experiments.
The basic usage principle is to define tracks, where each track can represent
genomic annotation, or a signal profile; subsequently we define the order
of the tracks and plot them.

Here we will define two tracks, a genome axis, which will show the position
along the human chromosome 21; and a signal track from our CTCF experiment.

```{r genome_browser.gviz}
library(Gviz)
# define the genome axis track
axis   = GenomeAxisTrack(GRanges('chr21', IRanges(1, width=seqlengths)))

# convert the signal into genomic ranges and define the signal track
gcov   = as(cov, 'GRanges')
dtrack = DataTrack(gcov, name = "CTCF", type='l')

# define the track ordering
track_list = list(axis,dtrack)
```

Tracks are plotted with the **plotTracks** function.
**sizes** argument needs to be the same size as the track_list, and defines the 
relative size of each track.

```{r genome-browser-gviz-show, fig.cap='ChIP-seq signal visualized as a browser track using Gviz'}
# plot the list of browser tracks
# sizes argument defines the relative sizes of tracks
# background title defines the color for the track labels
plotTracks(track_list, sizes=c(.1,1), background.title = "black")
```


### Plus and minus strand cross-correlation

Cross-correlation between plus and minus strands is a method
which quantifies whether the DNA library was enriched for fragments of 
a certain length.

Similarity between the plus and minus strands defined as the correlation of
the signal profiles for the reads that map to the **+** and the **-** strands.
The distribution of reads is shown on \@ref(fig:Figure_BrowserScreenshot)

```{r Figure-BrowserScreenshot, echo=FALSE, include=TRUE, fig.cap='Browser screenshot of aligned reads for one ChIP, and control sample. ChIP samples have an assymetric distribution of reads - reads mapping to the + strand are located on the left side of the peak, while the reads mapping to the - strand are found on the right side of the peak'}
knitr::include_graphics('./Figures/BrowserScreenshot.png')
```

Due to the  sequencing properties, reads which correspond to
the __5'__ fragment ends will map to the opposite strand then the reads
coming from the __3'__ ends. Most often (depending on the sequencing protocol) 
the reads from the __5'__ fragment ends map to the **+** strand, 
while the reads from the __3'__ ends map to the **-** strand.
 

We calculate the cross-correlation, by shifting the signal on the **+** strand,
by a pre-defined amount (i.e. shift by 1 - 400 nucleotides), and calculating, 
for each shift, the correlation between the **+**, and the **-** strands.
Subsequently we plot the correlation Vs shift, and locate the maximum value.
The maximum value should correspond to the average DNA fragment length which
was present in the library. This value tells us whether the ChIP enriched for
fragments of certain length (i.e. whether the ChIP was successful).

Due to the size of genomic data, it might be computationally prohibitive to 
calculate the Pearson correlation between whole genome (or even whole chromosome)
signal profiles.
To get around this problem, we will resort to a trick - we will disregard the dynamic
range of the signal profiles, and only keep the information of which
genomic bases contained the ends of the fragments.
This is done by calculating the coverage vector of read starting position (separately
for each strand), and converting the coverage vector into a boolean vector.
The boolean vector contains the information of which genomic positions
contained the DNA fragment ends.

Similarity between two boolean vectors can be promptly computed  using the Jaccard index.
Jaccard index is defined as an intersection between two boolean vectors, divided by their union as shown in Figure @\ref(fig:FigureJaccardSimilarity).

```{r, FigureJaccardSimilarity, echo=FALSE,fig.align = 'center', fig.cap="Jaccard similarity is defined as the ratio of the intersection and union of two sets."}
knitr::include_graphics('./Figures/Jaccard.png')
```



Firstly we load the reads for one of the CTCF ChIP experiments.
Then we create signal profiles, separately for reads on the  **+**, and  **-** 
strands.
Unlike before, we do not extend the reads to the average expected fragment
length (200 base pairs); we keep only the starting position of each read.

```{r correlatio.load}
# load the reads
reads = readGAlignments(chip_file)
reads = granges(reads)

# keep only the starting position of each read
reads = resize(reads, width=1, fix='start')

reads = keepSeqlevels(reads, 'chr21', pruning.mode='coarse')
```

Now we can calculate the coverage vector of read starting position.
The coverage vector is then automatically converted into a boolean vector by
asking which genomic positions have coverage > 0.

```{r correlation.coverage}
# calculate the coverage profile for plus and minus strand
reads = split(reads, strand(reads))

# coverage(x, width = seqlengths)[[1]] > 0 calculates the coverage and
# converts the coverage vector into a boolean
cov   = lapply(reads, function(x)coverage(x, width = seqlengths)[[1]] > 0)
cov   = lapply(cov, as.vector)
```

We will no shift the coverage vector from the plus strand by 1 - 400 base pairs, 
and for each pair shift we will calculate the Jaccard index between the vectors
on the plus and minus strand.

```{r correlation.jaccard, cache=TRUE}
# defines the shift range
wsize = 1:400

# defines the jaccard similarity
jaccard = function(x,y)sum((x & y)) / sum((x | y))

# shifts the + vector by 1 - 400 nucleotides and calculates the correlation coefficient
cc = shiftApply(wsize, cov[['+']], cov[['-']], FUN=jaccard)

# converts the results into a data frame
cc = data.frame(fragment_size = wsize, cross_correlation = cc)
```

We can finally plot the shift Vs the correlation coefficient:

```{r correlation-plot, fig.cap='The figure shows the correlation coefficient between the ChIP-seq signal on + and - strands. The peak of the distribution designates the fragment size'}
library(ggplot2)
ggplot(data = cc, aes(fragment_size, cross_correlation)) +
    geom_point() +
    geom_vline(xintercept = which.max(cc$cross_correlation), 
               size=2, color='red', linetype=2) +
    theme_bw() +
    theme(
        axis.text = element_text(size=10, face='bold'),
        axis.title = element_text(size=14,face="bold"),
        plot.title = element_text(hjust = 0.5)) +
    xlab('Shift in base pairs') +
    ylab('Jaccard similarity') 

```

The shift in base pairs which corresponds to the  maximum value of the correlation coefficient 
gives us an approximation to the expected average DNA fragment length. 
Because this value is not 0, or monotonically decreasing, we can conclude
that there was substantial enrichment of certain fragments in the ChIP samples.

### GC bias quantification

The PCR amplification procedure can cause a significant bias in the ChIP 
experiments. The bias can be influenced by the DNA fragment size distribution,
sequence composition, hexamer distribution of PCR primers, and the number of cycles used
for the amplification. 
One way how to determine whether some of the samples have significantly 
different sequence composition is to look at whether regions with 
differing GC composition were equally enriched in all experiments.

We will do the following: Firstly we will calculate the GC content of each
of the tilling windows, and then we will compare the GC content with the corresponding
cpm (count per million reads) value, for each tile.


```{r gc.tile}
# fetches the chromosome lengths and constructs the tiles
library(GenomeInfoDb)
library(GenomicRanges)

hg_chrs        = fetchExtendedChromInfoFromUCSC('hg38')
hg_chrs        = subset(hg_chrs, grepl('chr21$',UCSC_seqlevel))
seqlengths     = with(hg_chrs, setNames(UCSC_seqlength, UCSC_seqlevel))
tilling_window = unlist(tileGenome(seqlengths, tilewidth=1000))
```

We will extract the sequence information from the **BSgenome.Hsapiens.UCSC.hg38**
package. **BSgenome** are generic Bioconductor containers for genomic sequences.
Sequences are extracted from the **BSgenome** container using the **getSeq** function.
**getSeq** function takes as input the genome object, and the ranges with the 
regions of interest - in our case, the tilling windows.
The function returns a **DNAString** object.


```{r gc.getseq}
# loads the human genome sequence
library(BSgenome.Hsapiens.UCSC.hg38)

# extracts the sequence from the human genome
seq = getSeq(BSgenome.Hsapiens.UCSC.hg38, tilling_window)
```

```{r gc.getseq.head, include=TRUE, echo=FALSE, eval=TRUE}
head(seq[20000:20006])
```


To calculate the GC content, we will use the **oligonucleotideFrequency** on the
**DNAString** object. By setting the width parameter to 2 we will 
calculate the **dinucleotide** frequency. 
Each row in the resulting table will contain the number of all possible 
dinucleotides observed in each tilling window.
Because we have tilling windows of same length we do not 
necessarily need to normalize the counts by the window length.
If all of the windows do not have the same length (i.e. when looking
at the ChIP-seq peaks), then the normalization is a prerequisite.

```{r gc.oligo}
# calculates the frequency of all possible dimers in our sequence set
nuc = oligonucleotideFrequency(seq, width = 2)

# converts the matrix into a data.frame
nuc = as.data.frame(nuc)

# calculates the percentages, and rounds the number
nuc = round(nuc/1000,3)
```

```{r gc.oligo.head, include=TRUE, echo=FALSE, eval=TRUE}
head(nuc[20000:20006,])
```

Now we can combine the GC frequency with the cpm values.
We will convert the cpm values to the log10 scale. To avoid
taking the log(0), we add a pseudo count of 1 to cpm.

```{r gc.cpm, cache=TRUE}
# counts the number of reads per tilling window for each experiment
so = summarizeOverlaps(tilling_window, bam_files)

# converts the raw counts to cpm values
counts  = assays(so)[[1]]
cpm     = t(t(counts)*(1000000/colSums(counts)))
cpm_log = log10(cpm+1)
```

Combine the cpm values with the GC content, and plot the results.

```{r}
gc   = cbind(data.frame(cpm_log), GC = nuc['GC'])
```


```{r gc-plot, fig.cap='GC content abundance in a ChIP-seq experiment'}
ggplot(data = gc, aes(GC, GM12878_hg38_CTCF_r1.chr21.bam)) +
    geom_point(size=2, alpha=.3) +
    theme_bw() +
    theme(
        axis.text  = element_text(size=10, face='bold'),
        axis.title = element_text(size=14,face="bold"),
        plot.title = element_text(hjust = 0.5)) +
    xlab('GC content in one kilobase windows') +
    ylab('log10( cpm + 1 )') +
    ggtitle('CTCF Replicate 1')
```

CPM Vs GC content plot gives us two important pieces of information.
The first one is whether there was a specific amplification of regions
with extremely high or extremely low GC content. This would be strong indication
that the either the PCR or the size selection procedure were not successfully
executed.
The second piece of information comes by comparison of plots 
corresponding to multiple experiments. If different ChIP-samples have
highly diverging enrichment of different ChIP regions, this implies that
some of the samples were affected by unknown batch affects. Such effects
need to be taken into account in downstream analysis.

Firstly, we will reorder the columns of the data.frame using the gather 
function from the tidyr package

```{r gc.tidy}
# load the tidyr package
library(tidyr)

# gather converts a fat data.frame into a tall data.frame, which is
# the format used by the ggplot package
gcd = gather(data = gc, experiment, cpm, -GC)

# we select the ChIP files corresponding to the ctcf experiment
gcd = subset(gcd, grepl('CTCF', experiment))

# remove the chr21 suffix
gcd$experiment = sub('chr21.','',gcd$experiment)     

ggplot(data = gcd, aes(GC, log10(cpm+1))) +
    geom_point(size=2, alpha=.05) +
    theme_bw() +
    facet_wrap(~experiment, nrow=1)+
    theme(
        axis.text = element_text(size=10, face='bold'),
        axis.title = element_text(size=14,face="bold"),
        plot.title = element_text(hjust = 0.5)) +
    xlab('GC content in one kilobase windows') +
    ylab('log10( cpm + 1 )') +
    ggtitle('CTCF Replicates 1 and 2')
```


### Sequence read genomic distribution

The fourth way to look at the ChIP quality control is to visualize
the genomic distribution of reads in different functional genomic regions.
If the ChIP samples have the same distribution of reads as the Input samples,
this implies a lack of specific enrichment. Additionally, if we have
prior knowledge of where our proteins should be located, we can use
the visualization to judge how well the genomic distributions conform to our priors.
For example, the trimethylation of histone H3 on lysine 36 - H3K36me3 is associated
with elongating polymerase and productive transcription. If we performed a 
successful ChIP experiment with an anti-H3K36me3 antibody, we would expect most of the reads
to fall within gene bodies (introns and exons).

#### Hierarchical annotation of genomic features

Overlapping genomic features (a transcription start site of one
gene might be in an intron of another gene) will cause an ambiguity during
the read annotation. If a read overlaps more than one functional category, we are not
certain which category it should be assigned to.
To solve the problem of multiple assignments, we need to construct a set of annotation rules.
A heuristic solution is to organize the genomic annotation into a
hierarchy which will imply prioritization. 
We can then look, for each read, which functional categories it overlaps, and 
if it within multiple categories, we assign the read to the topmost category.
As an example, let's say that we have 4 genomic categories:

TSS (transcription start sites), exon, intron, intergenic, with the following 

hierarchy:

TSS -> exon -> intron -> intergenic

If a read overlaps a TSS and an intron, it will be annotates as TSS \@ref(fig:Figure_Hierarchical_Annotation).

```{r Figure-Hierarchical-Annotation, echo=FALSE, include=TRUE, fig.cap='Principle of hierarchical annotation. The region of interest is annotated as the topmost ranked category that it overlaps. In this case, our region overlaps a TSS, an exon, and a intergenic regions. Because the TSS has the topmost rank, it is annotated as a TSS.'}
knitr::include_graphics('./Figures/Hierarchical_Annotation.png')
```


Now we will construct the set of functional genomic regions, and annotate
the reads.

#### Finding Annotations

There are multiple sources of genomic annotation. UCSC, Genbank, and
ENSEMBL databases represent stable resources, from which the annotation
can be easily obtained.

**AnnotationHub** is a Bioconductor based online resource which contains a large
amount of experiments from various sources. 
We will use the AnnotationHub to download the location of genes corresponding
to the hg38 genome.

The hub is accessed in the following way:

```{r read_annot.hub}
# load the AnnotationHub package
library(AnnotationHub)

# connect to the hub object
hub = AnnotationHub()
```

The **hub** variable contains the programming interface towards the online database.
We can use the **query** function to find out the ID of the
ENSEMBL gene annotation.

```{r read_annot.query}
# query the hub for the human annotation
AnnotationHub::query(hub, c('ENSEMBL','Homo','GRCh38','chr','gtf'))
```

We are interested in the version GRCh38.92, which is available under **AH61126**.
To download the data from the hub, we use the **[[** operator on the
hub API.
We will download the annotation in the **.gtf** format, into a **GRanges** object.

```{r read_annot.fetch}
# retrieve the human gene annotation
gtf = hub[['AH61126']]
```


```{r read_annot.show, eval=TRUE, include=TRUE, echo=FALSE}
head(gtf)
```

By default the ENSEMBL project labels chromosomes using numeric identifiers (i.e. 1,2,3 ... X), 
without the __chr__ prefix.
We need to therefore append the prefix to the chromosome names (seqlevels).

```{r read_annot.seqlevels}
# paste the chr prefix to chromosome names
seqlevels(gtf, pruning.mode='coarse') = paste0('chr', seqlevels(gtf))
```

And finally we subset only regions which correspond to chromosome 21.

```{r read_annot.subset}
# keep only chromosome 21
gtf = gtf[seqnames(gtf) == 'chr21']
```

#### Constructing genomic annotation

Once we have downloaded the annotation we can define the functional hierarchy.
We will use the previously mentioned ordering:

TSS -> exon -> intron -> intergenic

With TSS having the highest priority and the intergenic regions having the lowest priority.


```{r read_annot.hierarchy}
# construct a GRangesList with human annotation
annotation_list = GRangesList(
    
    # promoters function extends the gtf around the TSS by an upstream and downstream amounts
    tss    = promoters(subset(gtf, type=='gene'), upstream=1000, downstream=1000),
    exon   = subset(gtf, type=='exon'),
    intron = subset(gtf, type=='gene')
)
```

#### Annotating reads

To annotate the reads we will define a function that takes as input a **.bam** file, 
and an annotation list, and returns the frequency of reads in each genomic category.
We will then loop over all of the **.bam** files to annotate each experiment.

**annotateReads** function works in the following way:

1. Load the **.bam** file

2. Find overlaps between the reads and the annotation categories

3. Arrange the annotated reads based on the hierarchy, and remove duplicated assignments

4. Count the number of reads in each category.


The crucial step to understand here is using the **arrange** and **filter** functions
to keep only one annotated category per read.


```{r read_annot.annotateReads}
annotateReads = function(bam_file, annotation_list){
    
    library(dplyr)
    message(basename(bam_file))
    
    # load the reads into R
    bam    = readGAlignments(bam_file)
    
    # find overlaps between reads and annotation
    result = as.data.frame(suppressWarnings(findOverlaps(bam, annotation_list))) 
    result$annotation = names(annotation_list)[result$subjectHits]
        
    # order the overlaps based on the hierarchy
    result = result[order(result$subjectHits),]
        
    # select only one category per read
    result = subset(result, !duplicated(queryHits))
        
    # count the number of reads in each category
    # group the result data frame by the corresponding category
    result = group_by(.data=result, annotation)
    
    # count the number of reads in each category
    result = summarise(.data = result, counts = length(annotation))
    
    # classify all reads which are outside of the annotation as intergenic
    result = rbind(result, data.frame(
                    annotation = 'intergenic',
                    counts     = length(bam) - sum(result$counts)))
    
    # calculate the frequency
    result$frequency  = with(result, round(counts/sum(counts),2))

    # append the experiment name
    result$experiment = basename(bam_file)
        
    return(result)
}
```

We execute the annotation function on all files.

```{r read_annot.loop}
# list all bam files in the folder
bam_files   = list.files(data_path, full.names=TRUE, pattern='bam$')

# calculate the read distribution for every file
annot_reads_list = lapply(bam_files, function(x)annotateReads(x, annotation_list))
```

And plot the results.

```{r read-annot-plot, fig.cap='ChIP-seq signal distribution over functional genomic features'}
# collapse the per-file read distributions into one data.frame
annot_reads_df = dplyr::bind_rows(annot_reads_list)

# format the experiment names
annot_reads_df$experiment = sub('.chr21.bam','',annot_reads_df$experiment)
annot_reads_df$experiment = sub('GM12878_hg38_','',annot_reads_df$experiment)


ggplot(data = annot_reads_df, aes(experiment, frequency, fill=annotation)) +
    geom_bar(stat='identity') +
    theme_bw() +
    scale_fill_brewer(palette='Set2') +
    theme(
        axis.text = element_text(size=10, face='bold'),
        axis.title = element_text(size=14,face="bold"),
        plot.title = element_text(hjust = 0.5),
        axis.text.x = element_text(angle = 90, hjust = 1)) +
    xlab('Sample') +
    ylab('Percentage of reads') +
    ggtitle('Percentage of reads in annotation')
```

We can observe a slight increase of H3K36me3 on the exons and introns, and H3K4me3
on the TSS. Interestingly, both replicates of the ZNF143 transcription factor show increased
read abundance around the TSS.

## Peak Calling

After we are convinced that the data is of sufficient quality, we can 
proceed with the downstream analysis.
One of he first steps in the ChIP-seq analysis is peak calling.
Peak calling is a statistical procedure, which uses coverage properties
of ChIP and Input samples to find regions which are enriched due to
protein binding.
The procedure requires mapped reads, and outputs a set of regions, which
represent the putative binding locations. Each region is usually associated 
with a significance score which is an indicator of enrichment.

For peak calling we will use the **normR** (ref) Bioconductor package.
**normR** uses a binomial mixture model, and performs simultaneous
normalization and peak finding. Due to the nature of the model, it is
quite plastic and can be used for different types of ChIP experiments.

One of the caveats of **normR** is that it does not inherently support
multiple biological replicates, for the same biological sample.
Therefore, the peak calling procedure needs to be done on each replicate
separately, and the peaks need to be combined in post-processing.


### Types of ChIP experiments

Based on the binding properties of ChIP-ped proteins, ChIP-seq
signal profiles can be divided into three classes:

1. **Sharp** (point signal) - A signal profile which is localized to specific 
short genomic regions (up to couple of hundred base pairs)
It is usually obtained from transcription factors, or highly localized posttranslational histone modifications 
(H3K4me3, which is found on gene promoters).

2. **Broad** (wide signal) - The signal covers broad genomic domains spanning up to several kilobases.
Usually produced by disperse histone modifications (H3K36me3, located
on gene bodies, or H3K23me3, which is deposited by the Polycomb complex in large genomic regions).

3. **Mixed** - The signal consists of a mixture of sharp and broad regions. 
It is produced by proteins which have dynamic behavior. Most often these are ChIP experiments
of RNA Polymerase 2. 

Different types of ChIP experiment usually require specialized analysis tools - 
some peak callers are developed to specifically detect narrow peaks[@zhang_2008; @xu_2010,@shao_2012], while others
detect enrichment in diffuse broad regions [@zang_2009; @micsinai_2012; @beck_2012,@song_2011 @xing_2012], 
or mixed (Polymerase 2) signals [@han_2012].
Recent developments in peak calling methods (such as **normR**) can however accommodate
multiple types of ChIP experiments [@rashid_2011].
The choice of the algorithm will largely depend on the type of the wanted
results, and the peculiarities of the experimental design and execution [@laajala_2009; @wilbanks_2010].

If you are not certain what kind of signal profile to expect from a ChIP-seq 
experiment, the best solution is to visualize the data.

We will now use the data from H3K3me36 (Sharp), H3K36me3 (Broad), and POL2 (Mixed)
ChIP experiments to show the differences in the signal profiles.

We will use the the bigWig files to visualize the signal profiles around a
highly expressed human gene from chromosome 21. This will give us an indication
of how the profiles for different types of ChIP experiments differ.

First we select the files of interest:

```{r chip_type.file}
# set names for chip-seq bigWig files
chip_files = list(
    H3K4me3  = 'GM12878_hg38_H3K4me3.chr21.bw',

    H3K36me3 = 'GM12878_hg38_H3K36me3.chr21.bw',

    POL2     = 'GM12878_hg38_POLR2A.chr21.bw'
)
# get full paths to the files
chip_files = lapply(chip_files, function(x)file.path(data_path, x))
```

Next we import the coverage profiles into **R**:

```{r chip_type.import}
# load rtracklayer
library(rtracklayer)

# import the ChIP bigWig files
chip_profiles = lapply(chip_files, rtracklayer::import.bw)
```

We fetch the reference annotation for human chromosome 21.

```{r chip_type.annotation, message = FALSE, error=FALSE,cache=TRUE}
library(AnnotationHub)
hub = AnnotationHub()
gtf = hub[['AH61126']]
seqlevels(gtf, pruning.mode='coarse') = '21'
seqlevels(gtf, pruning.mode='coarse') = paste0('chr', seqlevels(gtf))
```
To enable Gviz to work with genomic annotation we will convert the **GRanges**
object into a transcript database using the following function:

```{r chip_type.txdb, warning=FALSE}
# load the GenomicFeatures object
library(GenomicFeatures)

# convert the gtf annotation into a data.base
txdb         = makeTxDbFromGRanges(gtf)
```

And convert the transcript database into a Gviz track.

```{r chip_type.gene}
# define the gene track object
gene_track  = GeneRegionTrack(txdb, chr='chr21', genome='hg38')
```


Once we have downloaded the annotation, and imported the signal profiles into **R**
we are ready to visualize the data.
We will again use the **Gviz** library.

We firstly define the coordinate system - the ideogram track which will show
the position of our current viewpoint on the chromosome, and a genome axis track,
which will show the exact coordinates.

```{r chip_type.ideo}
# load Gviz package
library(Gviz)
# fetches the chromosome length information
hg_chrs = fetchExtendedChromInfoFromUCSC('hg38')
hg_chrs = subset(hg_chrs, (grepl('chr21$',UCSC_seqlevel)))

# convert data.frame to named vector
seqlengths = with(hg_chrs, setNames(UCSC_seqlength, UCSC_seqlevel))

# constructs the ideogram track
chr_track   = IdeogramTrack('chr21', 'hg38')

# constructs the coordinate system
axis        = GenomeAxisTrack(GRanges('chr21', IRanges(1, width=seqlengths)))
```

We use a loop to convert the signal profiles into a **DataTrack** object.

```{r chip_type.profile}
# use a lapply on the imported bw files to create the track objects
# we loop over experiment names, and select the corresponding object
# within the function
data_tracks = lapply(names(chip_profiles), function(exp_name){
    
    # chip_profiles[[exp_name]] - selects the proper experiment using the name
    DataTrack(chip_profiles[[exp_name]],   name = exp_name,  type='h', lwd=5)
})
```


We are finally ready to create the genome screenshot.
We will focus on an extended region around the URB1 gene.

```{r chip-type-plot-gviz, fig.cap='ChIP-seq signal around the URB1 gene'}
# select the start coordinate for the URB1 gene
start = min(start(subset(gtf, gene_name == 'URB1')))

# select the end coordinate for the URB1 gene
end   = max(end(subset(gtf, gene_name == 'URB1')))

# plot the signal profiles around the URB1 gene
plotTracks(c(chr_track, axis, gene_track, data_tracks),
           sizes=c(1,1,1,1,1,1), background.title = "black",
           collapseTranscripts = "longest", transcriptAnnotation="symbol",
           from = start - 5000,
           to   = end   + 5000)
```

The figure shows the signal profile around the URB1 gene.
H3K4me3 signal profile contains a strong narrow peak on the transcription start site.
H3K36me3 shows strong enrichment in the gene body, wile the POL2 ChIP shows
a mixed profile, with a strong peak at the TSS and an enrichment over the gene body.


### Peak Calling - Sharp Experiments

We will now use use **normR** [@helmuth_2016] for peak calling in sharp and broad peak experiments.

Select the input files. Since **normR** does not support the usage of biological
replicates, we will showcase the peak calling on one of the CTCF samples.

```{r peak_calling.sharp.files}
# full path to the ChIP data file
chip_file    = file.path(data_path, 'GM12878_hg38_CTCF_r1.chr21.bam')

# full path to the Control data file
control_file = file.path(data_path, 'GM12878_hg38_Input_r5.chr21.bam')
```

To a feeling about the dynamic range of enrichment we will create a scatter plot
showing the strength of signal in the CTCF and Input.

Let us first count the reads in 1kb windows, and normalize them to counts per
million sequenced reads.

```{r peak_calling.sharp.count}
# as previously done, we calculate the cpm for each experiment
library(GenomicRanges)
library(GenomicAlignments)

hg_chrs = fetchExtendedChromInfoFromUCSC('hg38') 
hg_chrs = subset(hg_chrs, grepl('chr21$',UCSC_seqlevel))

seqlengths = with(hg_chrs, setNames(UCSC_seqlength, UCSC_seqlevel))

tilling_window = unlist(tileGenome(seqlengths, tilewidth=1000))
counts         = summarizeOverlaps(tilling_window, c(chip_file, control_file))
counts         = assays(counts)[[1]]

cpm = t(t(counts)*(1000000/colSums(counts)))
```

We can now plot the ChIP Vs Input signal:

```{r peak-calling-sharp-plot, message = FALSE, erroe=FALSE, fig.cap='Comparison of CPM values between ChIP and Input experiments. Good ChIP experiments should always show enrichment'}
library(ggplot2)
# convert the matrix into a data.frame for ggplot
cpm = data.frame(cpm)
ggplot(data = cpm, aes(GM12878_hg38_Input_r5.chr21.bam, GM12878_hg38_CTCF_r1.chr21.bam)) +
    geom_point() +
    geom_abline(slope = 1) +
    theme_bw() +
    theme_bw() +
    scale_fill_brewer(palette='Set2') +
    theme(
        axis.text = element_text(size=10, face='bold'),
        axis.title = element_text(size=14,face="bold"),
        plot.title = element_text(hjust = 0.5),
        axis.text.x = element_text(angle = 90, hjust = 1)) +
    xlab('Input CPM') +
    ylab('CTCF CPM') +
    ggtitle('ChIP Vs Input')
    
```
Regions above the diagonal show higher enrichment in the ChIP samples, while
the regions below the diagonal show higher enrichment in the Input samples.


Let us now perform for peak calling.
**normR** usage is deceivingly simple - we need to provide the location
ChIP and Control read files, and the genome version to the **enrichR** function.
The function will automatically create tilling windows (250bp by default), 
count the number of reads in each window, and fit a mixture of 
binomial distributions.


```{r, peak_calling.sharp.peak_calling, message=FALSE, warning=FALSE}
library(normr)
# peak calling using chip and control
ctcf_fit = enrichR(
    
            # ChIP file
            treatment = chip_file,
            
            # control file
            control   = control_file,
            
            # genome version
            genome    = "hg38",
            
            # print intermediary steps during the analysis
            verbose   = FALSE)
```

With the summary function we can take look at the results:

```{r peak_calling.summary}
summary(ctcf_fit)
```

The summary function shows that most of the regions of the chromosome 21 correspond
to the background - 97.72%.
In total we have 1029 (627+120+195+87) significantly enriched regions.

We will now extract the regions into a **GRanges** object.
**getRanges** function extracts the regions from the model. Using the 
**getQvalue**, and **getEnrichment** function we assign to our regions 
the statistical significance and calculated enrichment. 
In order to identify only highly significant regions, 
we keep only ranges where the false discovery rate (q value) is below 0.01.

```{r peak_calling.sharp.peak_calling.ranges, cache=TRUE}
# extracts the ranges
ctcf_peaks = getRanges(ctcf_fit)
    
# annotates the ranges with the supporting p value
ctcf_peaks$qvalue     = getQvalues(ctcf_fit)
    
    # annotates the ranges with the calculated enrichment
ctcf_peaks$enrichment = getEnrichment(ctcf_fit)
    
# selects the ranges which correspond to the enriched class
ctcf_peaks = subset(ctcf_peaks, !is.na(component))
    
# Filter by a stringent q value threshold
ctcf_peaks = subset(ctcf_peaks, qvalue < 0.01)
    
# order the peaks based on the q value
ctcf_peaks = ctcf_peaks[order(ctcf_peaks$qvalue)]
```


```{r, peak_calling.sharp.peak_calling.show, include=TRUE, echo=FALSE, eval=TRUE}
ctcf_peaks
```
After stringent q value filtering we are left with 724 peaks.

For the ease of downstream analysis, we will limit the sequence levels to
chromosome 21.
```{r peak_calling.sharp.peak_calling.seqlevels}
seqlevels(ctcf_peaks, pruning.mode='coarse') = 'chr21'
```

Let's export the peaks into a .txt file which we can use downstream in the analysis.

```{r peak_calling.write_table, include=T, eval=T, echo=T}
# write the peaks loacations into a txt table
write.table(ctcf_peaks, file.path(data_path, 'CTCF_peaks.txt'), 
            row.names=F, col.names=T, quote=F, sep='\t')
```


We can now repeat the CTCF Vs Input plot, and label significantly marked peaks.

Using the count overlaps we mark which of our 1kb regions contained significant peaks.

```{r peak_calling.sharp.peak_calling.countOvlaps}
# find enriched tilling windows
enriched_regions = countOverlaps(tilling_window, ctcf_peaks) > 0
```


```{r peak-calling-sharp-peak-calling-plot, fig.cap='Comparison of signal between ChIP and input samples. Red labeled dots correspond to called peaks.'}
library(ggplot2)
cpm$enriched_regions = enriched_regions 
    
ggplot(data = cpm, aes(GM12878_hg38_Input_r5.chr21.bam, GM12878_hg38_CTCF_r1.chr21.bam, 
               color=enriched_regions)) +
    geom_point() +
    geom_abline(slope = 1) +
    theme_bw() +
    scale_fill_brewer(palette='Set2') +
    theme(
        axis.text = element_text(size=10, face='bold'),
        axis.title = element_text(size=14,face="bold"),
        plot.title = element_text(hjust = 0.5),
        axis.text.x = element_text(angle = 90, hjust = 1)) +
    xlab('Input CPM') +
    ylab('CTCF CPM') +
    ggtitle('ChIP Vs Input') +
    scale_color_manual(values=c('gray','red'))
```

We can see that **normR** identified all of the regions above the diagonal
as statistically significant. It has, however, labeled a significant
number of regions below the diagonal. Because the sophisticated statistical model, 
**normR** has greater sensitivity, and these peaks might really be enriched regions,
it is worth investigating the nature of these regions. This is left as an exercise
to the reader.

We can no create a genome browser screenshot around a peak regions.
This will show us what kind of signal properties have contributed to the peak calling.
We would expect to see a strong, bell shaped, enrichment in the ChIP sample, and a 
uniform noise in the Input sample.

Let us now visualize the signal around the most enriched peak:

The following function takes as input a **.bam** file, and loads the bam into R.
It extends the reads to a size of 200 bp, and creates the coverage vector.

```{r peak_calling.sharp.peak_calling.coverage,function}
# clauclate the coverage for one bam file
calculateCoverage = function(
    bam_file,
    extend = 200
){

    # load reads into R
    reads = readGAlignments(bam_file)
    
    # convert reads into a GRanges object
    reads = granges(reads)
    
    # resize the reads to 200bp
    reads = resize(reads, width=extend, fix='start')
    
    # get the coverage vector
    cov   = coverage(reads)
    
    # normalize the coverage vector to the sequencing depth
    cov = round(cov * (1000000/length(reads)),2)
    
    # convert the coverate go a GRanges object
    cov   = as(cov, 'GRanges')
    
    # keep only chromosome 21
    seqlevels(cov, pruning.mode='coarse') = 'chr21'
    return(cov)
}
```

Let's apply the function to the ChIP and input samples.

```{r peak_calling.sharp.peak_calling.coverage}
# calculate coverage for the ChIP file
ctcf_cov = calculateCoverage(chip_file)

# calculate coverage for the control file
cont_cov = calculateCoverage(control_file)
```

Using Gviz, we will construct the layered tracks.
First the genome coordinates

```{r peak_calling.sharp.peak_calling.gviz.axis}
# load Gviz and get the chromosome coordinates
library(Gviz)
chr_track  = IdeogramTrack('chr21', 'hg38')
axis       = GenomeAxisTrack(GRanges('chr21', IRanges(1, width=seqlengths)))
```

Then the peak locations

```{r peak_calling.sharp.peak_calling.gviz.peaks}
# peaks track
peaks_track = AnnotationTrack(ctcf_peaks, name = "CTCF Peaks")
```

And finally, the signal files

```{r peak_calling.sharp.peak_calling.gviz.signal}
chip_track  = DataTrack(ctcf_cov,   name = "CTCF",  type='h', lwd=3)
cont_track  = DataTrack(cont_cov,   name = "Input", type='h', lwd=3)
```


```{r peak-calling-signal-profile-plot, fig.cap='ChIP and Input signal profile in around the peak centers.'}
plotTracks(list(chr_track,
                axis, 
                peaks_track, 
                chip_track,
                cont_track), 
           sizes=c(.2,.5,.5,1,1), background.title = "black",
           from = start(ctcf_peaks)[1] - 1000,
           to   = end(ctcf_peaks)[1]   + 1000)
```

The ChIP sample looks as expected. Although the Input sample shows an enrichment, 
it is important to compare the scales on both samples. The normalized ChIP signal goes up 
to 2500, while the maximum value in the input sample is only 60.

 
### Broad regions

We will now use **normR** to call peaks for the H3K36me3 histone modification, 
which is associated with gene bodies of expressed genes.

We define the ChIP and Input files:

```{r peak_calling.broad.files}
# fetch the ChIP-file for H3k36me3
chip_file    = file.path(data_path, 'GM12878_hg38_H3K36me3.chr21.bam')

# fetch the corresponding input file
control_file = file.path(data_path, 'GM12878_hg38_Input_r5.chr21.bam')
```

Because H3K36 regions span broad domains it is necessary to increase the 
tilling window size which will be used for counting.
Using the **countConfiguration** function we will set the tilling window size
to 5000 base pairs.

```{r peak_calling.broad.config}
library(normr)
# define the window width for the counting
countConfiguration = countConfigSingleEnd(binsize = 5000)
```


```{r peak_calling.broad.normr, message=FALSE, warning=FALSE}
# find broad peaks using enrichR
h3k36_fit = enrichR(
            
            # ChIP file
            treatment   = chip_file,
            
            # control file
            control     = control_file,
            
            # Genome version
            genome      = "hg38",
            verbose     = FALSE,
            
            # window size for counting
            countConfig = countConfiguration)

```

```{r peak_calling.broad.summary}
summary(h3k36_fit)
```

The summary function shows that we get `r 1005+314+381+237` enriched regions.

We will extract enriched regions, and plot them in the same way we did for the
CTCF.

```{r peak_calling.broad.ranges}
# get the locations of broad peaks
h3k36_peaks            = getRanges(h3k36_fit)

# extract the qvalue and enrichment
h3k36_peaks$qvalue     = getQvalues(h3k36_fit)
h3k36_peaks$enrichment = getEnrichment(h3k36_fit)

# select proper peaks
h3k36_peaks = subset(h3k36_peaks, !is.na(component))
h3k36_peaks = subset(h3k36_peaks, qvalue < 0.01)
h3k36_peaks = h3k36_peaks[order(h3k36_peaks$qvalue)]

# collapse nearby enriched reginos
h3k36_peaks = reduce(h3k36_peaks)
```

```{r peak_calling.broad.tracks}
# construct the data tracks for the H3k36me3 and Input files
h3k36_cov = calculateCoverage(chip_file)
data_tracks = list(
    h3k36 = DataTrack(h3k36_cov,  name = 'h3k36_cov',  type='h', lwd=3),
    input = DataTrack(cont_cov,   name = 'Input',  type='h', lwd=3))
```


```{r peak-calling-broad-gviz, fig.cap='Visualization of H3K36me3 ChIP signal on a called broad peak.'}
# define the window for the visualization
start = min(start(h3k36_peaks[2])) - 25000
end   = max(end(h3k36_peaks[2])) + 25000

# create the peak track
peak_track = AnnotationTrack(reduce(h3k36_peaks), name='h3k36me3')

# plots the enriched region
plotTracks(c(chr_track, axis, gene_track, peak_track, data_tracks),
           sizes=c(.5,.5,.5,.1,1,1), background.title = "black",
           collapseTranscripts = "longest", transcriptAnnotation="symbol",
           from = start,
           to   = end)
```

The figure shows a highly enriched H3K36me3 region covering the gene body, 
as expected.


### Peak quality control

Peak calling is not a mathematically defined procedure - it is impossible
to unambiguously define what a "peak" is. Therefore all of the peak
calling procedures use heuristics, and statistical models which have been
show to work well in specific use-cases.
After peak calling it is always necessary to check
whether the defined peaks really are located in enriched regions, and in addition, 
use prior knowledge to ascertain whether the peaks correspond to known biology.

Peak calling can falsely identify enriched regions if the input
sample is not sequenced to the proper depth. Because the input samples
correspond to __de facto__ whole genome sequencing, and the ChIP procedure
enriches for a subset of the genome, it can often happen that many regions
in the the genome are not sufficiently covered by the Input sample.
Such variability in the signal profile of Input samples can cause a region
to be defined as a peak - enriched in the ChIP sample, while in reality it is depleted in the
Input, due to under-sampling. For example, the figure in the previous chapter, showing
an enriched region H3K36me3 over a gene body, shows a large depletion in the Input
sample over the same region. Such depletion should be a concern and merit
further investigation.

The quality of enrichment can be checked by calculating the percentage of reads within peaks for both
ChIP and Input samples. ChIP samples should have a high percentage of reads in peaks,
while for the input samples the percentage of reads should correspond to the
percentage of genome covered by peaks.

For transcription factor ChIP experiments, an important control is to determine whether
the peak regions contain sequences which are known to be bound
by the corresponding transcription factor - whether they contain
known transcription factor binding motifs. 
Transcription factor binding motifs are sequence models which model the propensity
of binding DNA sequences.
Such sequence models can be downloaded from public databases and compared to see
whether there is a positional enrichment around our peaks.

We will now calculate the percentage of reads within peaks for H3K36me3 experiment.
Subsequently, we will download the known CTCF sequence model, and compare it
to our peak regions.


#### Percentage of reads in peaks

To calculate the reads in peaks, we will firstly extract the number of reads
in each tilling window from the **normR** produced fit object.
This is done using the **getCounts** function.
We will then use the q value to define which tilling windows correspond
to peaks, and count the number of reads within and outside peaks.


```{r peak_quality.counts}
# extract, per tilling window, counts from the fit object
h3k36_counts = data.frame(getCounts(h3k36_fit))
    
# change the column names of the data.frame
colnames(h3k36_counts) = c('Input','H3K36me3')
    
# extract the q value corresponding to each bin
h3k36_counts$qvalue = getQvalues(h3k36_fit)
    
# define which regions are peaks using a q value cutoff
h3k36_counts$enriched[is.na(h3k36_counts$qvalue)]  = 'Not Peak'
h3k36_counts$enriched[h3k36_counts$qvalue > 0.05]  = 'Not Peak'
h3k36_counts$enriched[h3k36_counts$qvalue <= 0.05] = 'Peak'
    
# remove the q value column
h3k36_counts$qvalue = NULL 
    
# reshape the data.frame into a long format
h3k36_counts_df = tidyr::gather(data=h3k36_counts, experiment, counts, -enriched)
    
# sum the number of reads in the Peak and Not Peak regions
h3k36_counts_df = group_by(.data = h3k36_counts_df, experiment, enriched)
h3k36_counts_df = summarize(.data = h3k36_counts_df, num_of_reads = sum(counts))
    
# calculate the percentage of reads.
h3k36_counts_df       = group_by(.data = h3k36_counts_df, experiment)
h3k36_counts_df       = mutate(.data = h3k36_counts_df, total=sum(num_of_reads))
h3k36_counts_df$percentage = with(h3k36_counts_df, round(num_of_reads/total,2))
```


```{r, peak_quality.counts.show, eval=TRUE, echo=FALSE, include=TRUE}
h3k36_counts_df
```

We can now plot the percentage of reads in peaks:

```{r peak-quality-counts-plot, fig.cap='Percentage of ChIP read in called peaks. Higher percentage indicates higher ChIP quality.'}
ggplot(data = h3k36_counts_df, aes(experiment, percentage, fill=enriched)) +
    geom_bar(stat='identity', position='dodge') +
    theme_bw() +
    theme(
        axis.text = element_text(size=10, face='bold'),
        axis.title = element_text(size=12,face="bold"),
        plot.title = element_text(hjust = 0.5)) +
    xlab('Experiment') +
    ylab('Percetage of reads in region') +
    ggtitle('Percentage of reads in peaks for H3K36me3') +
    scale_fill_manual(values=c('gray','red'))
```
The figure shows that the ChIP sample is clearly enriched
in the peak regions.
The percentage of read in peaks will depend on the quality of the antibody (strength of
enrichment), and the size of peaks which are bound by the protein of interest.
If the total size of peaks is small, relative to the genome size, we can expect that
the percentage of reads in peaks will be small.
For in depth consideration about the appropriate percentage thresholds see (ref)


#### DNA Motifs

Well studied transcription factor have publicly available transcription
factor binding motifs.
If such a model is available for our transcription factor of interest, we
can use ti to check the quality of our ChIP data.
Two common measures are used for this purpose:

1. Percentage of peaks containing the motif of interest.

2. Positional distribution of the motif - the distribution of motif locations should be
centered on the peak centers.

##### Percentage of peaks with motif

We will firstly calculate the percentage of CTCF peaks which contain a know CTCF
motif. DNA binding motifs can be extracted from the **MotifDB** Bioconductor
database. The **MotifDB** is an agglomeration of multiple motif databases.

```{r peak_quality.motifdb}
# load the MotifDB packge
library(MotifDb)

# fetch the CTCF motif from the data base
motifs = query(query(MotifDb, 'Hsapiens'), 'CTCF')

# show all available ctcf motifs
motifs
```

We will extract the CTCF from the [@khan_2018] database.

```{r, peak_quality.jaspar}
ctcf_motif  = motifs[[9]]
```

The downloaded motif is a matrix with dimensions 4 X N. The matrix
contains 4 rows where each row corresponds to one nucleotide (A, C, G, T). 
The number of columns designates the width of the region bound by the transcription factor.
Each element of the matrix contains the probability of observing the corresponding
nucleotide on this position.
For example, for following the CTCF matrix, the probability of observing a thymine at
the first position of the motif is 0.57 (1st column, 4th row).
Such a matrix, where each column is a probability distribution of over a sequence of nucleotides
is called a position frequency matrix - PFM.
Such matrices are constructed from sequences which were experimentally verified sequences, using
a motif finding algorithm.



```{r peak_quality.show, echo=FALSE, include=TRUE, eval=TRUE}
ctcf_motif
```

Each path through the matrix calculates the probability that the transcription factor
will bind one sequence \@ref(fig:Figure_PWMScanning).

```{r Figure-PWMScanning, echo=FALSE, include=TRUE, fig.cap='PWM scanning principle. A genomic sequence is scanned by a scoring matrix. The scoring matrix defines how likely is that the transcription factor will bind each nucelotide in each position. Here we are looking at how likely it is that our TF will bind to the sequence ACACT. The score for this sequence is 1.1. The maximal score obtainable by the PWM is 2.7. Because 1.1 / 2.7 = 0.4, and 0.4 is lower than our designated threshold of 0.8, we conclude that the ACACT sequence will not be bound by our TF of interest.'}
knitr::include_graphics('./Figures/PWMScanning.png')
```


Such a matrix can be used to calculate the probability that the transcription
factor will any sequence. 


Using the PFM, we can calculate the information content of each position in the matrix.
The information content quantifies the contribution of each nucleotide to the
cumulative binding preference (how important each nucleotide is for the binding).
It additionally allows us to visually represent the probability matrices as sequence logos.
The information content is quantified as Shannon entropy. It ranges from 0 - no information,
to 2 - maximal information

Shannon entropy formula:
\[
entropy = -\sum\limits_{i=1}^n p_{i}\log_2(p_i) 
\]

We will use now the **seqLogo** package to visualize the information content of the 
CTCF motif.
The figure shows which are the most important nucleotides for CTCF binding.

```{r peak-quality-seqLogo, fig.cap="CTCF sequence motif visualized as a sequence logo. Y axis ranges from zero to two, and corresponds to the amount of information each base in the motif contributes to the overall motif. The larger the letter the greater the probability of observing just one defined base on the designated position."}
# plot the seqLogo of the CTCF motif
seqLogo::seqLogo(ctcf_motif)
```


To annotate the CTCF peaks with the motif, we will firstly extend the peak
regions to +/- 200 bp around the peak center.
Because the average fragment size is 200 bp, 400 nucleotides is the
expected variation in the position of the true binding location.

```{r peak_quality.scan.resize}
# extend the peak regions
ctcf_peaks_resized = resize(ctcf_peaks, width = 400, fix='center')
```

Now we use the **BSgenome** package to extract the sequences corresponding to the peak regions.


```{r peak_quality.scan.getSeq}
# load the human genome sequenct
library(BSgenome.Hsapiens.UCSC.hg38)

# extract the sequences around the peaks
seq = getSeq(BSgenome.Hsapiens.UCSC.hg38, ctcf_peaks_resized)
```

```{r peak_quality.scan.show, include=TRUE, echo=FALSE, eval=TRUE}
head(seq)
```

Once we have extracted the sequences, we can use the CTCF motif to 
scan each sequences and determine the probability of CTCF binding.
For this we use the **TFBSTools** [@TFBSTools] package.

We first convert the raw probability matrix into a **PWMMatrix** object, 
which can then be used for efficient scanning.

```{r, peak_quallity.scan.tfbs}
# load the TFBS tools package
library(TFBSTools)

# Convert the matrix into a PWM object
ctcf_pwm = PWMatrix(ID='CTCF', profileMatrix = ctcf_motif)
```

We can now use the **searchSeq** function to scan each sequence for the motif occurrence.
Because the motif matrices are give a continuous binding score, we need to set a cutoff to 
determine when a sequence contains the motif, and when it doesn't.
The cutoff is set by determining the maximal possible score produced by the motif matrix;
a percentage of that score is then taken as the threshold value.
For example, if the best sequence would have a score of 1.4 of being bound,
then we define a threshold of 80% of 1.4, which is 1.12; and any sequence which
scores less that 1.12 would not be marked as being bound by the protein.

For the CTCF, we mark any peak containing a sequence with > 80% of the maximal
score as a positive hit.

```{r peak_quality.scan.scan, include=TRUE, echo=FALSE, eval=TRUE}
# scan the CTCF peaks to find the locations of the motif around peaks
hits = searchSeq(ctcf_pwm, seq, min.score="80%", strand="*")

# convert the hits into a data.frame
hits = as.data.frame(hits)
```


```{r, peak_quality.scan.scan.show, echo=FALSE, eval=TRUE, include=TRUE}
head(hits)
```

A common diagnostic plot is to graph a reverse cumulative distribution of 
peak occurrences.
On the X axis we rank the peaks, with the most highly enriched peak on the
first position, and the least enriched peak on the last position.
We then walk from the lowest to the highest ranking and measure the
percentage of peaks containing the motif.

```{r, peak-quality-scan-dist-plot, fig.cap="Percentage of peaks containing the motif'. Higher percentage indicates a better ChIP-experiment, and a better peak calling procedure."}
# label which peaks contain CTCF motifs
motif_hits_df = data.frame(
    peak_order     = 1:length(ctcf_peaks)
)
motif_hits_df$contains_motif = motif_hits_df$peak_order %in% hits$seqnames
motif_hits_df = motif_hits_df[order(-motif_hits_df$peak_order),]

# calculate the percentage of peaks with motif for peaks of descenting strength
motif_hits_df$perc_peaks = with(motif_hits_df, round(cumsum(contains_motif)/max(peak_order),2))

# plot the cumulative distribution of motif hit percentages
ggplot(motif_hits_df, aes(peak_order, perc_peaks)) +
    geom_line(size=2) +
    theme_bw() +
    theme(
        axis.text = element_text(size=10, face='bold'),
        axis.title = element_text(size=14,face="bold"),
        plot.title = element_text(hjust = 0.5)) +
    xlab('Peak rank') +
    ylab('Percetage of peaks with motif') +
    ggtitle('Percentage of CTCF peaks with the CTCF motif')
```

The figure shows that, when we take all peaks into account ~45% of
the peaks contain a CTCF motif.
This is an excellent percentage and indicates a high quality ChIP experiment.
Our inability to locate the motif in ~50% of the sequences does not
necessarily need to be a consequence of a poor experiment - sometimes
it is a result of the molecular mechanism of by which the transcription factor
binds. If a transcription factor has multiple binding modes, which are context 
dependent - for example, if the transcription factor binds indirectly to
a subset of regions, through
an interacting partner, we do not have to observe a motif.


#### Motif Localization

If the ChIP experiment was performed properly, we would expect the motif
to be localized just below the summit of each peak.
By plotting the motif localization around ChIP peaks, we are quantifying
the uncertainty in peak location.

We will firstly resize our peaks into regions around +/- 1kb around the peak
center.

```{r chip_quality.motifloc.resize}
# resize the region around peaks to +/- 1kb
ctcf_peaks_resized = resize(ctcf_peaks, width = 2000, fix='center')
```

Now we perform the motif localization, as before.

```{r chip_quality.motifloc.scan}
# fetch the sequence
seq = getSeq(BSgenome.Hsapiens.UCSC.hg38,ctcf_peaks_resized)

# convert the motiv matrix to PWM, and scan the peaks
ctcf_pwm    = PWMatrix(ID='CTCF', profileMatrix = ctcf_motif)
hits = searchSeq(ctcf_pwm, seq, min.score="80%", strand="*")
hits = as.data.frame(hits)
```

We now construct a plot, where the 
X axis represents the +/ 1000 nucleotides around the peak, while the
Y axis shows the motif enrichment at each position.

```{r chip-quality-motifloc-plot, fig.cap='Transcription factor sequence motif localization with respect to the defined binding sites.'}
# set the position relative to the start
hits$position = hits$start - 1000 

# plot the motif hits around peaks
ggplot(data=hits, aes(position)) +
    geom_density(size=2) +
    theme_bw() +
    geom_vline(xintercept = 0, linetype=2, color='red', size=2) +
    xlab('Position around the CTCF peaks') +
    ylab('Per position percentage\nof motif occurence') +
    theme(
        axis.text = element_text(size=10, face='bold'),
        axis.title = element_text(size=14,face="bold"),
        plot.title = element_text(hjust = 0.5))
```

We can see that the bulk of motif hits are found in a region of +/- 250 bp 
around the peak centers. This means that the peak calling procedure was quite precise.


### Peak Annotation

As the final step of quality control we will visualize the distribution
of peaks in different functional genomic regions.
The purpose of the analysis is to check whether the location of the peaks
conforms with our prior knowledge.
This analysis is equivalent to constructing distributions for reads.

Firstly we download the human gene models and construct the annotation hierarchy.

```{r peak_annotation.hub}
# Download the annotation
hub = AnnotationHub()
gtf = hub[['AH61126']]
seqlevels(gtf, pruning.mode='coarse') = '21'
seqlevels(gtf, pruning.mode='coarse') = paste0('chr', seqlevels(gtf))

# Create the annotation hierarchy
annotation_list = GRangesList(
    tss    = promoters(subset(gtf, type=='gene'), 1000, 1000),
    exon   = subset(gtf, type=='exon'),
    intron = subset(gtf, type=='gene')
)
```

The following function finds the genomic location of each peak, annotates
the peaks using the hierarchical prioritization, and calculates the summary statistics.

```{r peak_annotation.function}
# function which annotates the location of each peak
annotatePeaks = function(peaks, annotation_list, name){
    
    # collapse touching enriched regions
    peaks = reduce(peaks)
    
    # find overlaps between the peaks and annotation_list
    result = as.data.frame(suppressWarnings(findOverlaps(peaks, annotation_list)))
    
    # fetch annotation names
    result$annotation = names(annotation_list)[result$subjectHits]
    
    # rank by annotation precedence
    result = result[order(result$subjectHits),]    
    
    # remove overlapping annotations
    result = subset(result, !duplicated(queryHits))
        
    # count the number of peaks in each annotation category
    result = group_by(.data = result, annotation)
    result = summarise(.data = result, counts = length(annotation))
    
    # fetch the number of intergenic peaks
    result = rbind(result, 
                   data.frame(annotation = 'intergenic', 
                              counts     = length(peaks) - sum(result$counts)))
        
    result$frequency  = with(result, round(counts/sum(counts),2))
    result$experiment = name
        
    return(result)
}
```

```{r peak_annotation.list}
peak_list = list(CTCF     = ctcf_peaks, 
                 H3K36me3 = h3k36_peaks)

# calculate the distribution of peaks in annotation for each experiment
annot_peaks_list = lapply(names(peak_list), function(peak_name){
        annotatePeaks(peak_list[[peak_name]], annotation_list, peak_name)
    })
```

```{r peak-annotation-plot, fig.cap='Enrichment of transcription factor or histone modifications in functional genomic features'}
# combine a list of data.frames into one data.frame
annot_peaks_df = dplyr::bind_rows(annot_peaks_list)

# plot the distrubtion of peaks in genomic features
ggplot(data = annot_peaks_df, aes(experiment, frequency, fill=annotation)) +
    geom_bar(stat='identity') +
    scale_fill_brewer(palette='Set2') +
    theme_bw()+
    theme(
        axis.text = element_text(size=18, face='bold'),
        axis.title = element_text(size=14,face="bold"),
        plot.title = element_text(hjust = 0.5))  +
    ggtitle('Peak distribution in\ngenomic regions') +
    xlab('Experiment') +
    ylab('Frequency')
```

The plot shows that the H3K36me3 peaks are located preferentially in gene bodies,
as expected, while the CTCF peaks are found preferentially in introns.



## Motif Discovery

The first analysis step downstream of peak calling is motif discovery.
Motif discovery is a procedure of finding enriched sets of similar short sequences
in a large sequence data set. In our case the large sequence data set are 
sequences around ChIP peaks, while the short sequence sets are the transcription
factor binding sites.

There are two types of motif discovery tools: supervised, and unsupervised.

Supervised tools require explicit positive (we are certain that the motif is enriched),
and negative sequence sets (we are certain that the motif is not enriched), and
then search for relative enrichment of short motifs in the foreground versus
the background.
Unsupervised models, on the other hand, require only a set of positive sequences,
and then compare motif abundance to a statistically constructed background set.

Due to the combinatorial nature of the procedure, motif discovery is 
computational expensive. It is therefore often performed on a subset of the
highest quality peaks.

In this tutorial we will use **motifRG** [@MotifRG] for motif discovery.
**motifRG** is a supervised motif discovery tools, which therefore uses
two sets of sequences: a foreground and a background data set.
The method uses logistic regression to find enriched short motifs.

We will firstly load our CTCF peaks, and convert them to a GRanges object.
We will then select the top 250 peaks, and extract the DNA sequence, which
will be used as the foreground.
The background set will be constructed by shifting the peaks by 5kb.
Once we have identified the enriched motifs, they we will annotate them, 
by comparing them with a database of motifs.

Load the CTCF peaks, and select the top 250 peaks.

```{r motif_discovery.peak}
# read the CTCF peaks created in the peak calling part of the tutorial
ctcf_peaks = read.table(file.path(data_path, 'CTCF_peaks.txt'), header=TRUE)

# convert the peaks into a GRanges object
ctcf_peaks = makeGRangesFromDataFrame(ctcf_peaks, keep.extra.columns = TRUE)

# order the peaks by qvalue, and take top 250 peaks
ctcf_peaks = ctcf_peaks[order(ctcf_peaks$qvalue)]
ctcf_peaks = head(ctcf_peaks, n = 250)

# merge nearby CTCF peaks
ctcf_peaks = reduce(ctcf_peaks)
```

Create a region of +/- 100 bp around the center of the peaks, 

```{r motif_discovery.resize}
# expand the CTCF peaks
ctcf_peaks_resized = resize(ctcf_peaks, width = 200, fix='center')
```

and extract the genomic sequence.

```{r motif_discovery.foreground}
# fetch the sequence around the peaks
library(BSgenome.Hsapiens.UCSC.hg38)
ctcf_seq = getSeq(BSgenome.Hsapiens.UCSC.hg38, ctcf_peaks_resized)
```

We construct the background set randomly shuffling the CTCF sequences.
This can be achieved using the **sample** function on a **DNAString** object.
Before the **sample** function, we set the seed for the random number generator.

```{r motif_discovery.background}
# set the seed for the random number generator
set.seed(1)

# shuffle the ctcf sequences
back_seq = DNAStringSet(lapply(ctcf_seq, sample))
```

We are finally ready to do motif discovery.
This is executed using the **findMotifFgBg** function.
The primary two arguments are the foreground and the background sequence 
data sets.
We additionally define the maximal number of motifs, that
we are interested only in motifs which are enriched in the foreground data sets, 
and that the motif width should be at least 15 base pairs.
**both.strand** parameter designates that the motifs could be located both
on the supplied sequences and their reverse complements.

```{r motif_discovery.motifrg, warning=FALSE, message=FALSE, results = 'hide', include=FALSE, eval=TRUE, echo=FALSE, cache=TRUE}
# load the motifRG package for calling peaks
library(motifRG)

# make the analysis deterministic by fixing the random number generator
set.seed(1)

# do the motif discovery
motifs = findMotifFgBg(
    
    # chip peaks
    fg.seq        = ctcf_seq,
    
    # background regions
    bg.seq        = back_seq,
    
    # number of motifs
    max.motif     = 1,
    
    # find only enriched motifs
    enriched.only = TRUE,
    
    # maximal motif width
    max.width     = 15,
    
    # should the motif be located on only one or both strands
    both.strand   = TRUE
)
```

```{r, warning=FALSE, message=FALSE, eval=FALSE}
library(motifRG)
set.seed(1)
motifs = findMotifFgBg(
    fg.seq        = ctcf_seq,
    bg.seq        = back_seq,
    max.motif     = 1,
    enriched.only = TRUE,
    max.width     = 15,
    both.strand   = TRUE
)
```


Once the motif finding procedure is done, we need to refine the motif edges.
This is done using the **refinePWMMotifExtend** function.

```{r motif_discovery.motifrefine, warning=FALSE, message=FALSE, results = 'hide', include=FALSE, eval=TRUE, echo=FALSE}
# use the refine function to trim low information content positions
refined_motifs = lapply(motifs$motifs, function(x){
    motifRG::refinePWMMotifExtend(motifs = x@match$pattern, seqs = ctcf_seq)
    })

```

```{r, warning=FALSE, message=FALSE, results = 'hide', eval=FALSE}
refined_motifs = lapply(motifs$motifs, function(x){
    motifRG::refinePWMMotifExtend(motifs = x@match$pattern, seqs = ctcf_seq)
})
```


We will visualize the refined motif using the **seqLogo** function
from the same package,

```{r motif_discovery.seqlogo}
# visualize the resulting motif
seqLogo::seqLogo(refined_motifs[[1]]$model$prob)
```


### Motif annotation

We will now compare our unknown motif with the JASPAR2018 database, to
figure out to which transcription factor it corresponds.
Firstly we convert the frequency matrix into a **PWMatrix** object, and
then use this object to query the database.

```{r motif_annotation.pwm}
# convert the novel motif into a PWMatrix object
library(TFBSTools)
unknown_motif = refined_motifs[[1]]$model$prob
unknown_pwm   = PWMatrix(ID = 'unk', 
                         profileMatrix = unknown_motif)
```

Using the **getMatrixSet** function we extract all motifs which 
correspond to known human transcription factors.

```{r motif_annotation.jaspar}
# load the JASPAR motif database
library(JASPAR2018)

# extract motifs corresponding to human transcription factors
pwm_library = getMatrixSet(
  JASPAR2018,
  opts=list(
    collection = 'CORE',
    species    = 'Homo sapiens',
    matrixtype = 'PWM'
  ))
```

The **PWMSimilarity** function calculates the Pearson correlation between
the database, and our unknown motif.

```{r motif_annotation.similarity}
# find the most similar motif to our motif
pwm_sim = PWMSimilarity(
    
    # JASPAR library
    pwm_library, 
    
    # out motif
    unknown_pwm,
    
    # measure for comparison
    method = 'Pearson')
```

We extract the motif names from the PWM library. For each motif
in the library we append the Pearson correlation with our unknown motif, and
look at the topmost candidates.

```{r motif_annotation.table, message=FALSE, warning=FALSE}
# extract the motif names from the pwm library
pwm_library_list = lapply(pwm_library, function(x){
    data.frame(ID = ID(x), name = name(x))
})
# combine the list into one data frame
pwm_library_dt = dplyr::bind_rows(pwm_library_list)

# fetch the similarity of each motif to our unknown motif
pwm_library_dt$similarity = pwm_sim[pwm_library_dt$ID]

# find the most similar motif in the library
pwm_library_dt = pwm_library_dt[order(-pwm_library_dt$similarity),]
```

```{r motif_annotation.head}
head(pwm_library_dt)
```

As expected, the topmost candidate is CTCF.


## What to do next?

Knowing every location in the genome bound by a protein can provide a lot
of mechanistic information, however, quite often it is hard to make
biologically relevant conclusions just from one ChIP-seq experiment (i.e. if
we want to explain how our protein causes a disease, it is hard to guess
which of the tens of thousands of binding places is relevant for the phenotype).
Therefore, it is customary to integrate the results with data which is already available
for our system of interest - ChIP-seq of different proteins, genome wide measurements of 
expression, or assays of 3D genome structure.

The choice of downstream analysis is guided by the biological question of interest.
Often we want to compare our samples to other available ChIP-seq experiments.
It is possible to look at the pairwise differences between samples using 
differential peak calling [@zhang_2014,@lun_2014,@allhoff_2014,@allhoff_2016].
It is a procedure analogous to the differential expression analysis, except it 
results in sets of coordinates that are differentially bound in two biological 
conditions. We can then search for specific DNA binding motif in such regions, 
or correlate changes in the binding with changes in gene expression.
With an increase in number of ChIP experiment, pairwise comparisons becomes
combinatorially complex. In this case we can segment the genome into multiple classes, where
each class corresponds to a combination of bound transcription factors.
Genome segmentation is usually done using probabilistic models (such as hidden
Markov models [@ernst_2012,@hoffman_2012]), or machine learning algorithms [@mortazavi_2013].


## Exercises:

### Basic

#### Quality control:
        
1. Apply the fragment size estimation procedure to all ChIP and Input available data sets

2. Visualize the resulting distributions. 

3. How does the Input sample distribution differ from the ChIP samples?

#### Genome Browser:

1. Write a function which converts the bam files into bigWig files.

2. Apply the function to all files, and visualize them in the Genome browser.
Observe the signal profiles, what can you notice, about the similarity of the samples?
        
3. Use GViz to visualize the profiles for CTCF, SMC3 and ZNF143
        
#### Cross correlation:
    
1. Calculate the cross correlation for the both CTCF replicates, and
the input samples. How does the profile look for the control samples?

2. Calculate the cross correlation coefficients for all samples and 
visualize them as a heatmap.

### Intermediate


1. Use normR to call peaks for all SMC3, CTCF, and ZNF143 samples.

2. Calculate the percentage of reads in peaks for the CTCF experiment

3. Download the blacklisted regions corresponding to the hg38 human genome, and calculate
the percentage of CTCF peaks falling in such regions.

### Advanced

1. Unify the biological replicates by taking an intersection of peaks.
How many peaks are specific to each biological replicate, and how many peaks overlap.
    
2. Plot a scatter plot of signal strengths for biological replicates. Do intersecting
peaks have equal signal strength in both samples.

3. Quantify the combinatorial binding of all three proteins. Find
the number of places which are bound by all three proteins, by 
a combination of two proteins, and exclusively by one protein.
Annotate the different regions based on their genomic location.

4. Correlate the normR enrichment score for CTCF with peak presence/absence.
(create boxplots of enrichment for peaks which contain and do not contain CTCF motifs)

5. Explore the co-localization of CTCF and ZNF143. Where are the co-bound
regions located? Which sequence motifs do they contain? Download the ChIA-pet
data for the GM12878 cell line, and look at the 3D interaction between different
classes of binding sites.


```{r include=FALSE, eval=TRUE, echo=FALSE}
rm(list=ls())
gc()
```




